# is-practice

&emsp;&emsp;leetcode练习

+ ps: 将ch2中的CMakeLists.txt和.vscode拷贝到其他路径下, 然后修改CMakeLists.txt和.vscode中的ch2字段为ch4，即可用vscode进行编译, 调试，

## demo: 工程样例
## bit-operation: lcc136(只出现一次的数字)、lcc169(只出现一次的数字 II, 统计每一位1的个数, 看是否可以对3整除)
## l109: 有序链表转换二叉搜索树
## l312: 戳气球
## l583: 两个字符串的删除操作
## ch10: 八皇后问题(TODO, \*\*\*)
## ch13: lcc132(分割回文串2)
## putshoe: 忘记题目了，leetcode没有(TODO, \*\*)
## ch2

+ lcc26(删除排序数组中的重复项)
+ lcc80(删除排序数组中的重复项2)
+ lcc33(搜索旋转排序数组)
+ lcc81(索旋转排序数组2)
+ lcc4(寻找两个有序数组的中位数)
+ lcc298(二叉树最长连续序列)
+ lcc1(两数之和)
+ lcc259(较小的三数之和)
+ lcc16(最接近的三数之和)
+ lcc454(四数相加)
+ lcc27(移除元素)
+ lcc31(下一个排列)
+ lcc60(第k个排列)
+ lcc36(有效的数独)
+ lcc42(接雨水)
+ lcc48(旋转图像)
+ lcc66(加一)
+ lcc746(使用最小花费爬楼梯 )
+ lcc89(格雷编码)
+ lcc73(矩阵置零)
+ lcc134(加油站)
+ lcc575(分糖果)
+ lcc619(只出现一次的最大数字)
+ lcc137(只出现一次的数字2)

## ch3

+ lcc125(验证回文串)
+ lcc28(实现 strStr())
+ lcc8(字符串转换整数 (atoi)
+ lcc67(二进制求和)
+ lcc516(最长回文子序列)
+ lcc44(通配符匹配)

## ch4

+ lcc84(柱状图中最大的矩形)

## ch5

+ lcc889(根据前序和后序遍历构造二叉树)
+ lcc94(二叉树的中序遍历)
+ lcc106(从中序与后序遍历序列构造二叉树)
+ lcc105(从前序与中序遍历序列构造二叉树)
+ lcc95(不同的二叉搜索树2)

## ch6

+ lcc41(缺失的第一个正数)

## ch7

+ lcc715(Range 模块)
+ lcc35(搜索插入位置)
+ lcc74(搜索二维矩阵)

## ch8

+ lcc115(不同的子序列)
+ lcc77(组合)

## dynamic-programming

+ lc338(Counting Bits, bit manipulation)
+ lc647(Palindromic Substrings[考虑下怎么去除二维数组)
+ lc120(Triangle)
+ lc474(Ones and Zeroes)
+ lcc5(最长回文)
+ lcc121(maxprofit)
+ lc53(maxsubarray)
+ lc198(rob)
+ lcc62(uniquepaths)
+ lcc63(uniquePathsWithObstacles)
+ lcc264(nthUglyNumber)
+ lcc279(numSquares)
+ lcc300(lengthOfLIS)
+ lcc303(区域和检索 - 数组不可变)
+ lcc304(二维区域和检索 - 矩阵不可变)

## graph-search

+ lc559(Maximum Depth of N-ary Tree)
+ lc513(Find Bottom Left Tree Value)
+ lcc133(克隆图)

## linear_structure

+ lc344(Reverse String)
+ lc763(Partition Labels)
+ lc876(Middle of the Linked List)
+ lc817(Linked List Components, 这道题不对)
+ lcc2(两数相加)
+ lc682(Baseball Game)
+ lc921(Minimum Add to Make Parentheses Valid(stack, Greedy)

## tree_structure

+ lc687(Longest Univalue Path)
+ lc852(Peak Index in a Mountain Array)
+ lcc94(中序遍历)
+ lcc144(先序遍历)
+ lcc145(后序遍历)
+ lcc95(generate tree)
+ lcc96(不同的二叉搜索树)
+ lcc98(验证的二叉搜索树)
+ lcc104(二叉树的最大深度)
+ lcc105(从前序与中序遍历序列构造二叉树)
+ lcc99(恢复二叉搜索树)
+ lcc101(对称二叉树)
+ lcc102(二叉树的层次遍历)
+ lcc103(二叉树的锯齿形层次遍历)
+ lcc107(二叉树的层次遍历2)
+ lcc108(有序数组转换为二叉搜索树)
+ lcc110(平衡二叉树)
+ lcc111(二叉树的最小深度)
+ lcc112(路径总和, TODO\*\*\*)
+ lcc199(二叉树的右视图), 在leetcode没找到左视图，但我觉得差不多, 这两道题的代码都写了
+ all_leaf(在leetcode妹搜到，忘记当时解决什么问题了, 感觉是与左视图、右视图相似的递补视图，需要回忆,TODO, \*\*\*)
